#+STATUS: "mustread" "important" "interesting" ""
#+COLUMNS: %120ITEM %STATUS
#+OPTIONS: num:nil author:t prop:t toc:t
#+AUTHOR: Roberto Bifulco, Gábor Rétvári
#+TITLE: The Programmable Data Plane: Reading List
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>
#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>
#+HTML_HEAD: <style>.example{border:0px solid; background:#ffffff; padding:0px; margin-top:0px;margin-bottom:0px;font-family:"Bitstream Vera Sans", Verdana, sans-serif;font-style: italic;}</style>
# \bibliography{./prog_data_plane.bib}
# \bibliographystyle{plain}

/See the [[https://rg0now.github.io/prog_dataplane_reading_list/README.html][HTML version]] for a nicely formatted version./

This is a reading list for students, practitioners, and researchers
interested in the general area of programmable data plane devices,
including SmartNICs, programmable middleboxes and software/hardware
switches, everything that may underlie a software-defined network. The
reading list completes the survey paper "TODO".

The reading list is organized into a rough hierarchy based on the major
topics of /Abstractions/, /Architecture/, and /Miscellanea/; note that this
hierarchy is more or less arbitrary and the purpose is just to have /some/
organization at all. The individual papers are tagged as "mustread",
"important", and "interesting" (available only in the HTML version), with
the approximate meaning "read at least these papers to get a good
understanding of the area", "papers for getting more familiar with some
sub-areas", and "interesting contributions to the field",
respectively. Just like the hierarchy, the tags are also pretty much
arbitrary and follow the subjective views of the authors; your mileage may
vary.

/Note:/ Some of the linked papers are behind paywalls. We double-checked
that all listed papers can be accessed freely by a moderate amount of
googling; we still provide the paywall links as user-provided PDFs often do
not prove overly stable over time.

* Abstractions

** Languages and Compilers

*** Low-level APIs

**** McKeown et al.: [[http://doi.acm.org/10.1145/1355734.1355746][*OpenFlow: Enabling Innovation in Campus Networks*]], /ACM SIGCOMM Comput. Commun. Rev./, 2008.
     :PROPERTIES:
     :RELEVANCE:   mustread
     :END:
THe OpenFlow whitepaper. The original idea in OpenFlow was to provide a way
for researchers to run experimental protocols in the networks they use
every day. OpenFlow is based on an Ethernet switch, with an internal
flow-table, and a standardized interface to add and remove flow entries.
This allowed, in addition to allowing researchers to evaluate their ideas
in real-world traffic settings, for OpenFlow to serve as a useful campus
component in large-scale testbeds.

**** Duncan et al.: [[https://ieeexplore.ieee.org/iel5/5166953/5166954/05167027.pdf][*packetC: Language for High Performance Packet Processing*]], /IEEE HPCC/, 2009.
     :PROPERTIES:
     :RELEVANCE:   interesting
     :END:
This paper describes a model which combines a parallel model and
heterogeneous multiprocessor implementations.  The parallel packet
processing model uses coarse-grain, SPMD parallelism to free users from
thread management and it requires the host system to locate protocol
headers in the packet before a parallel copy of the program executes.  The
packetC language abstracts and encapsulates familiar packet processing data
sets and operations into new aggregate data types and operators, e.g., for
packets, databases and searchsets. 

**** Song et al.: [[http://doi.acm.org/10.1145/2491185.2491190][*Protocol-oblivious Forwarding: Unleash the Power of SDN Through a Future-proof Forwarding Plane*]], /ACM HotSDN/, 2013.
     :PROPERTIES:
     :RELEVANCE:   important
     :END:
As an alternative to P4, Protocol-Oblivious Forwarding (POF) is presented
as a key enabler for highly flexible and programmable SDN. The goal is to
remove any dependency on protocol-specific configurations on the forwarding
elements and, in addition to P4's stateless design, enhance the data-path
with new stateful instructions to support genuine software defined
networking behavior. A generic flow instruction set (FIS) is defined to
fulfill this purpose and both hardware-based and open source software-based
prototypes are shown to demonstrate the feasibility and advantages of POF.

**** Bosshart et al.: [[http://www.sigcomm.org/sites/default/files/ccr/papers/2014/July/0000000-0000004.pdf][*P4: Programming protocol-independent packet processors*]], /ACM SIGCOMM Comput. Commun. Rev./, 2014.
     :PROPERTIES:
     :RELEVANCE:   mustread
     :END:
This seminal paper introduces P4, a high-level language for programming
protocol-independent packet processors. P4 has three goals: (1)
reconfigurability, in that programmers can change the way switches process
packets once they are deployed, (2) protocol independence, in that switches
are not tied to any specific network protocols, and (3) target
independence, in that programmers can describe packet-processing
functionality independently of the specifics of the underlying
hardware. The paper demonstrates P4 by showing configure a switch to add a
new hierarchical label.

**** Shahbaz et al.: [[http://doi.acm.org/10.1145/2774993.2775000][*The Case for an Intermediate Representation for Programmable Data Planes*]], /ACM SOSR/, 2015.
     :PROPERTIES:
     :RELEVANCE:   important
     :END:
The paper introduces NetASM, an intermediate representation for
programmable data planes. NetASM is a device-independent language that is
expressive enough to act as the target language for compilers for
high-level languages, yet low-level enough to be efficiently assembled on
various device architectures. It enables conventional compiler optimization
techniques to significantly improve the performance and resource
utilization of custom packet-processing pipelines on a variety of targets.

**** Bifulco et al.: [[http://doi.acm.org/10.1145/2890955.2890962][*Improving SDN with InSPired Switches*]], /ACM SOSR/, 2016.
     :PROPERTIES:
     :RELEVANCE:   mustread
     :END:
The paper proposes an API for programming the generation of packets in
programmable switches, instead of forging network packets on the controller
side.  The InSP API allows a programmer to define in-switch packet
generation operations, which include the specification of triggering
conditions, packet's content and forwarding actions.

**** Choi et al.: [[https://www.cs.princeton.edu/~mshahbaz/papers/sosr17demos-pvpp.pdf][*PVPP: A Programmable Vector Packet Processor*]], /ACM SOSR/, 2017.
     :PROPERTIES:
     :RELEVANCE:   interesting
     :END:
PVPP is a data-plane program compiler from P4, a data plane DSL based on
match-action tables, to the fd.io Vector Packet Processor (VPP) software
switch, based on the packet processing node graph model. PVPP compiles a
data plane program written in P4 to VPP's internal graph
representation. 

*** High-level Languages and Compilers

**** Christopher Monsanto et al.: [[https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final232.pdf][*Composing Software Defined Networks*]], /USENIX NSDI/, 2013.
     :PROPERTIES:
     :RELEVANCE:   mustread
     :END:
The paper introduces Pyretic, a novel programming language for writing
composable SDN applications using a set of high level topology and
packet-processing abstractions. Pyretic improves on Frenetic (an earlier
incarnation of a similar language) by adding support for sequential
composition, the use of topology abstractions to define what each module
can see and do with the network, and an abstract packet model that
introduces virtual fields into packets. Modular applications are written
using the static policy language NetCore, which provides primitive actions,
matching predicates, query policies, and policies.

**** Voellmy et al.: [[https://conferences.sigcomm.org/sigcomm/2013/papers/sigcomm/p87.pdf][*Maple: simplifying SDN programming using algorithmic policies*]], /ACM SIGCOMM Comput. Commun. Rev./, 2013.
     :PROPERTIES:
     :RELEVANCE:   important
     :END:
The paper presents Maple, a system that simplifies SDN programming by (1)
allowing a programmer to use a standard programming language to design an
arbitrary, centralized algorithm, to decide the behavior of an entire
network, and (2) providing an abstraction that the programmer-defined,
centralized policy runs on every packet entering a network, and hence is
oblivious to the challenge of translating a high-level policy into sets of
rules on distributed individual switches. To implement algorithmic policies
efficiently, Maple includes not only a highly-efficient multicore
scheduler, but more importantly a novel tracing runtime optimizer that can
automatically record reusable policy decisions, offload work to switches
when possible, and keep switch flow tables up-to-date by dynamically
tracing the dependency of policy decisions on packet contents as well as
the environment. 

**** Foster et al.: [[http://frenetic-lang.org/publications/overview-ieeecoms13.pdf][*Languages for software-defined networks*]], /IEEE Communications Magazine/, 2013.
     :PROPERTIES:
     :RELEVANCE:   mustread
     :END:
An easily approachable survey on higher-level abstractions for creating and
composing packet processing applications using the Frenetic framework.

**** Bonelli et al.: [[http://doi.acm.org/10.1145/2658260.2658269][*A Purely Functional Approach to Packet Processing*]], /IEEE/ACM ANCS/, 2014.
     :PROPERTIES:
     :RELEVANCE:   interesting
     :END:
The paper introduces PFQ-Lang, an extensible functional language to
process, analyze and forward packets, which allows easy development by
leveraging functional composition and allows to exploit multi-queue NICs
and multi-core architectures.

**** Lavanya Jose et al.: [[https://www.usenix.org/conference/nsdi15/technical-sessions/presentation/jose][*Compiling Packet Programs to Reconfigurable Switches*]], /USENIX NSDI/, 2015.
     :PROPERTIES:
     :RELEVANCE:   mustread
     :END:
Seminal paper exploring the design of a compiler for programmable switching
chips, in particular how to map logical lookup tables to physical tables
while meeting data and control dependencies in the program. A Integer
Linear Programming (ILP) and greedy approach is presented to generate
solutions optimized for latency, pipeline occupancy, or power
consumption. The authors show benchmarks from real production networks to
two different programmable switch architectures: RMT and Intel’s FlexPipe.

**** Firestone et al.: [[https://www.usenix.org/system/files/conference/nsdi17/nsdi17-firestone.pdf][*VFP: A Virtual Switch Platform for Host Sdn in the Public Cloud*]], /USENIX NSDI/, 2017.
     :PROPERTIES:
     :RELEVANCE:   important
     :END:
The paper presents the Virtual Filtering Platform (VFP), a programmable
virtual switch that powers Microsoft Azure, a large public cloud. VFP
includes support for multiple independent network controllers, policy based
on connections rather than only on packets, efficient caching and
classification algorithms for performance, and efficient offload of flow
policy to programmable NICs. The paper presents the design of VFP and its
API, its flow language and compiler used for flow processing, performance
results, and experiences deploying and using VFP in Azure over several
years.

**** Wang et al.: [[https://www.cs.cornell.edu/~jnfoster/papers/p4fpga.pdf][*P4FPGA: A Rapid Prototyping Framework for P4*]], /ACM SOSR/, 2017.
     :PROPERTIES:
     :RELEVANCE:   interesting
     :END:
P4FPGA is a tool for developing and evaluating data plane applications. It
is both an open-source compiler and runtime; the compiler in turn extends
the P4.org reference compiler with a custom backend that generates FPGA
code. By combining high-level programming abstractions offered by P4 with a
flexible and powerful hardware target, P4FPGA may allow developers to
rapidly prototype and deploy new data plane applications.

** Abstractions for Embedded State

**** Verdú et al.: [[http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=ED2CCB19D8967081D9DE927A7AB43614?doi=10.1.1.482.5955&rep=rep1&type=pdf][*Workload Characterization of Stateful Networking Applications*]], /IEEE HPC/, 2008.
     :PROPERTIES:
     :RELEVANCE:   important
     :END:
This paper presents the first workload characterization of stateful
networking applications. The analysis emphasizes the study of data cache
behaviour, but discusses branch prediction, instruction distribution,
etc. Another important contribution is the study of the state categories of
different networking applications. 

**** Bianchi et al.: [[http://doi.acm.org/10.1145/2602204.2602211][*OpenState: Programming Platform-independent Stateful Openflow Applications Inside the Switch*]], /ACM SIGCOMM Comput. Commun. Rev./, 2014.
     :PROPERTIES:
     :RELEVANCE:   mustread
     :END:
The paper tackles the challenge to devise a stateful data plane programming
abstraction (versus the stateless OpenFlow match/action table abstraction)
which still entails high performance and remains consistent with vendors'
preference for closed platforms. The authors posit that a promising answer
revolves around the usage of extended finite state machines, as an
extension (super-set) of the OpenFlow match/action abstraction, turn the
proposed abstraction into an actual table-based API, and we show how it can
be supported by (mostly) reusing core primitives already implemented in
OpenFlow devices.

**** Moshref et al.: [[http://doi.acm.org/10.1145/2620728.2620729][*Flow-level State Transition As a New Switch Primitive for SDN*]], /ACM HotSDN/, 2014.
     :PROPERTIES:
     :RELEVANCE:   interesting
     :END:
The paper proposes FAST (Flow-level State Transitions) as a new switch
primitive for software-defined networks. With FAST, the controller simply
preinstalls a state machine and switches can automatically record flow
state transitions by matching incoming packets to installed filters. FAST
can support a variety of dynamic applications, and can be readily
implemented with commodity switch components and software switches.

**** Arashloo et al.: [[http://doi.acm.org/10.1145/2934872.2934892][*SNAP: Stateful Network-Wide Abstractions for Packet Processing*]], /ACM SIGCOMM/, 2016.
     :PROPERTIES:
     :RELEVANCE:   important
     :END:
SNAP offers a simpler "centralized" stateful programming model on top of
the simple match-action paradigm offered by OpenFlow.  SNAP programs are
developed on a one-big-switch abstraction and may contain reads and writes
to global, persistent arrays, allowing programmers to implement a broad
range of stateful applications. The SNAP compiler then distributes, places,
and optimizes access to these stateful arrays, discovering read/write
dependencies and translating one-big-switch programs into an efficient
internal representation based on a novel variant of binary decision
diagrams.

**** Sivaraman et al.: [[http://doi.acm.org/10.1145/2934872.2934900][*Packet Transactions: High-Level Programming for Line-Rate Switches*]], /ACM SIGCOMM/, 2016.
     :PROPERTIES:
     :RELEVANCE:   important
     :END:
This paper shows how to program data-plane algorithms in a high-level
language and compile those programs into low-level microcode that can run
on programmable line-rate switching chips. The key challenge is that many
data-plane algorithms create and modify algorithmic state. To achieve
line-rate programmability for stateful algorithms, the paper introduces the
notion of a packet transaction: a sequential packet-processing code block
that is atomic and isolated from other such code blocks. The idea is
developed in Domino, a C-like imperative language to express data-plane
algorithms, and many examples are shown that can be run at line rate with
modest estimated chip-area overhead.

**** Giuseppe Bianchi et al.: [[http://arxiv.org/abs/1605.01977][*Open Packet Processor: a programmable architecture for wire speed platform-independent stateful in-network processing*]], /unpublished manuscript/, 2016.
     :PROPERTIES:
     :RELEVANCE:   interesting
     :END:
This paper aims at contributing to the debate on how to bring
programmability of stateful packet processing tasks inside the network
switches, while retaining platform independency. The proposed approach,
named "Open Packet Processor" (OPP), shows the viability of eXtended Finite
State Machines (XFSM) as low-level data plane programming
abstraction. Platform independence is accomplished by decoupling the
implementation of hardware primitives from their usage by an application
formally described via an abstract XFSM.

**** Luo et al.: [[http://doi.acm.org/10.1145/3050220.3050233][*Swing State: Consistent Updates for Stateful and Programmable Data Planes*]], /ACM SOSR/, 2017.
     :PROPERTIES:
     :RELEVANCE:   interesting
     :END:
The paper presents Swing State, a general state-management framework and
runtime system supporting consistent state migration in stateful data
planes. The key insight is to perform state migration entirely within the
data plane by piggybacking state updates on live traffic. To minimize the
overhead, Swing State only migrates the states that cannot be safely
reconstructed at the destination switch. A prototype of Swing State for P4
is also described.

**** Dargahi et al.: [[https://doi.org/10.1109/COMST.2017.2689819][*A Survey on the Security of Stateful SDN Data Planes*]], /IEEE Communications Surveys Tutorials/, 2017.
     :PROPERTIES:
     :RELEVANCE:   important
     :END:
The paper provides the reader with a background on stateful SDN data plane
proposals, focusing on the security implications that data plane
programmability brings about, identifies potential attack scenarios, and
highlights possible vulnerabilities specific to stateful in-switch
processing, including denial of service and saturation attacks.

**** Murad Kablan et al.: [[https://www.usenix.org/conference/nsdi17/technical-sessions/presentation/kablan][*Stateless Network Functions: Breaking the Tight Coupling of State and Processing*]], /USENIX NSDI 17/, 2017.
     :PROPERTIES:
     :RELEVANCE:   mustread
     :END:
The paper presents Stateless Network Functions, a new architecture for
network functions virtualization, where the existing design of network
functions is decomposed into a stateless processing component along with a
data-store layer. The StatelessNF processing instances are architected
around efficient pipelines utilizing DPDK for high performance network I/O,
packaged as Docker containers for easy deployment, and a data store
interface optimized based on the expected request patterns to efficiently
access a RAMCloud-based data store. A network-wide orchestrator monitors
the instances for load and failure, manages instances to scale and provide
resilience, and leverages an OpenFlow-based network to direct traffic to
instances. 

** Programmable Parsing and Scheduling

**** Gibb et al.: [[https://doi.org/10.1109/ANCS.2013.6665172][*Design principles for packet parsers*]], /IEEE/ACM ANCS/, 2013.
     :PROPERTIES:
     :RELEVANCE:   important
     :END:
The paper presents an interesting view on parser design and the trade-offs
between different designs, asking whether it is better to design one fast
parser or several slow parsers, what are the costs of making the parser
reconfigurable in the field, and what design decisions most impact power
and area. The paper describes trade-offs in parser design, identifies
design principles for switch and router architects, and describes a parser
generator that outputs synthesizable Verilog that is available for
download.

**** Radhika Mittal et al.: [[https://www.usenix.org/conference/nsdi16/technical-sessions/presentation/mittal][*Universal Packet Scheduling*]], /USENIX NSDI/, 2016.
     :PROPERTIES:
     :RELEVANCE:   interesting
     :END:
The addresses a seemingly simple question: Is there a universal packet
scheduling algorithm? It turns out that in general the answer is "no";
however, the authors manage to show that the classical Least Slack Time
First (LSTF) scheduling algorithm comes closest to being universal and it
can closely replay a wide range of scheduling algorithms. LSTF is evaluated
as to whether in practice it can meet various network-wide objectives; the
authors find that LSTF performs comparable to the state-of-the-art for each
of performance metric. 

**** Sivaraman et al.: [[http://doi.acm.org/10.1145/2934872.2934899][*Programmable Packet Scheduling at Line Rate*]], /ACM SIGCOMM/, 2016.
     :PROPERTIES:
     :RELEVANCE:   important
     :END:
Similarly to the "Universal Packet Scheduling" paper, this paper presents
another design for a programmable packet scheduler, which allows scheduling
algorithms, potentially algorithms that are unknown today, to be programmed
into a switch without requiring hardware redesign.  The design uses the
property that scheduling algorithms make two decisions, in what order to
schedule packets and when to schedule them, and exploits that in many
scheduling algorithms definitive decisions on these two questions can be
made when packets are enqueued. The resultant design uses a single
abstraction: the push-in first-out queue (PIFO), a priority queue that
maintains the scheduling order or time.

**** Sivaraman et al.: [[http://doi.acm.org/10.1145/2535771.2535796][*No Silver Bullet: Extending SDN to the Data Plane*]], /ACM HotNets/, 2013.
     :PROPERTIES:
     :RELEVANCE:   interesting
     :END:
Instead of going with a universal scheduler, the authors argue that
Software-Defined Networking must be extended to control the fast-path
scheduling and queueing behavior of a switch. To this end, they propose
adding a small FPGA to switches, and synthesize, place, and route hardware
implementations for CoDel and RED.

* Programmable Switch Architectures

** Software Switch Architectures

*** Viability of Software Switching

**** Egi et al.: [[http://doi.acm.org/10.1145/1544012.1544032][*Towards High Performance Virtual Routers on Commodity Hardware*]], /ACM CoNEXT/, 2008.
     :PROPERTIES:
     :RELEVANCE:   interesting
     :END:
The paper is the first to study the performance limitations when building
both software routers and software virtual routers on commodity CPU
platforms. The authors observe that the fundamental performance bottleneck
is the memory system, and that through careful mapping of tasks to CPU
cores one can achieve very high forwarding rates. The authors also identify
principles for the construction of high-performance software router systems
on commodity hardware.

**** Greenhalgh et al.: [[http://www.sigcomm.org/sites/default/files/ccr/papers/2009/April/1517480-1517484.pdf][*Flow Processing and the Rise of Commodity Network Hardware*]], /SIGCOMM Comput. Commun. Rev./, 2009.
     :PROPERTIES:
     :RELEVANCE:   mustread
     :END:
The paper introduces the FlowStream switch architecture, which enables flow
processing and forwarding at unprecedented flexibility and low cost by
consolidating middlebox functionality, such as load balancing, packet
inspection and intrusion detection, and commodity switch technologies,
offering the possibility to control the switching of flows in a
fine-grained manner, into a single integrated package deployed on commodity
hardware.

**** Dobrescu et al.: [[http://kfall.net/ucbpage/papers/sosp09.pdf][*RouteBricks: exploiting parallelism to scale software routers*]], /ACM SOSP/, 2009.
     :PROPERTIES:
     :RELEVANCE:   interesting
     :END:
RouteBricks is concerned with enabling high-speed parallel processing in
software routers, using a software router architecture that parallelizes
router functionality both across multiple servers and across multiple cores
within a single server. RouteBricks adopts a fully programmable Click/Linux
environment and is built entirely from off-the-shelf, general-purpose
server hardware.

*** The Dataflow Graph Abstraction

**** Morris et al.: [[https://pdos.csail.mit.edu/papers/click:tocs00/paper.pdf][*The Click modular router*]], /ACM Trans. on Computer Systems/, 2000.
     :PROPERTIES:
     :RELEVANCE:   mustread
     :END:
Introduces Click, a software architecture for building flexible and
configurable routers from packet processing modules implementing simple
router functions like packet classification, queuing, scheduling, organized
into a directed graph with packet processing modules at the vertices;
packets flow along the edges of the graph.

**** Sun et al.: [[https://dl.acm.org/citation.cfm?id=2537861][*Fast and Flexible: Parallel Packet Processing with GPUs and Click*]], /IEEE/ACM ANCS/, 2013.
     :PROPERTIES:
     :RELEVANCE:   important
     :END:
The paper introduces Snap, a framework for packet processing that exploits
the parallelism available on modern GPUs, while remaining flexible, with
packet processing tasks implemented as simple modular elements that are
composed to build fully functional routers and switches. Snap is based on
the Click modular router, which it extends by adding new architectural
features that support batched packet processing, memory structures
optimized for offloading to coprocessors, and asynchronous scheduling with
in-order completion. 

**** Sangjin Han et al.: [[http://www.eecs.berkeley.edu/Pubs/TechRpts/2015/EECS-2015-155.pdf][*SoftNIC: A Software NIC to Augment Hardware*]], /unpublished manuscript/, 2015.
     :PROPERTIES:
     :RELEVANCE:   important
     :END:
SoftNIC is a hybrid software-hardware architecture to bridge the gap
between limited hardware capabilities and ever changing user
demands. SoftNIC provides a programmable platform that allows applications
to leverage NIC features implemented in software and hardware, without
sacrificing performance. This paper serves the foundation for the BESS
software switch.

**** Sangjin Han et al.: [[http://span.cs.berkeley.edu/bess.html][*Berkeley Extensible Software Switch*]], /project website/, 2015.
     :PROPERTIES:
     :RELEVANCE:   important
     :END:
BESS is the Berkeley Extensible Software Switch developed at the University
of California, Berkeley and at Nefeli Networks. BESS is heavily inspired by
the Click modular router, representing a packet processing pipeline as a
dataflow (multi)graph that consists of modules, each of which implements a
NIC feature, and ports that act as sources and sinks for this
pipeline. Packets received at a port flow through the pipeline to another
port, and each module in the pipeline performs module-specific operations
on packets. 

**** Honda et al.: [[http://doi.acm.org/10.1145/2774993.2775065][*mSwitch: A Highly-scalable, Modular Software Switch*]], /ACM SOSR/, 2015.
     :PROPERTIES:
     :RELEVANCE:   interesting
     :END:
The authors make the observation that it is difficult to simultaneously
provide high packet rates, high throughput, low CPU usage, high port
density and a flexible data plane in a same architecture. A new
architecture called mSwitch is proposed and four distinct modules are
implemented on top: a learning bridge, an accelerated Open vSwitch module,
a protocol demultiplexer for userspace protocol stacks, and a filtering
module that can direct packets to virtualized middleboxes.

**** Aurojit Panda et al.: [[https://www.usenix.org/system/files/conference/osdi16/osdi16-panda.pdf][*NetBricks: Taking the V out of NFV*]], /USENIX OSDI/, 2016.
     :PROPERTIES:
     :RELEVANCE:   interesting
     :END:
NetBricks is an NFV framework adopting the "graph-based" pipeline
abstraction and embracing type checking and safe runtimes to provide
isolation efficiently in software, providing the same memory isolation as
containers and VMs without incurring the same performance penalties. The
new isolation technique is called zero-copy software isolation.

*** The Match-action Abstraction

**** Ben Pfaff et al.: [[https://www.usenix.org/conference/nsdi15/technical-sessions/presentation/pfaff][*The Design and Implementation of Open vSwitch*]], /USENIX NSDI/, 2015.
     :PROPERTIES:
     :RELEVANCE:   mustread
     :END:
The paper describes the design and implementation of Open vSwitch, a
multi-layer, open source virtual switch. The design document details the
advanced flow classification and caching techniques that Open vSwitch uses
to optimize its operations and conserve hypervisor resources.

**** Shahbaz et al.: [[http://doi.acm.org/10.1145/2934872.2934886][*PISCES: A Programmable, Protocol-Independent Software Switch*]], /ACM SIGCOMM/, 2016.
     :PROPERTIES:
     :RELEVANCE:   interesting
     :END:
PISCES is a software switch derived from Open vSwitch (OVS), a hypervisor
switch whose behavior is customized using P4. PISCES is not hard-wired to
specific protocols; this independence makes it easy to add new
features. The paper also shows how the compiler can analyze the high-level
P4 specification to optimize forwarding performance; the evaluations show
that PISCES performs comparably to OVS but PISCES programs are about 40
times shorter than equivalent OVS source code.

**** Ethan Jackson et al.: [[https://www.usenix.org/conference/atc16/technical-sessions/presentation/jackson][*SoftFlow: A Middlebox Architecture for Open vSwitch*]], /USENIX ATC/, 2016.
     :PROPERTIES:
     :RELEVANCE:   interesting
     :END:
The paper presents SoftFlow, an extension to Open vSwitch that seamlessly
integrates middlebox functionality while maintaining the familiar OpenFlow
forwarding model and performing significantly better than alternative
techniques for middlebox integration.

**** Molnár et al.: [[http://doi.acm.org/10.1145/2934872.2934887][*Dataplane Specialization for High-performance OpenFlow Software Switching*]], /ACM SIGCOMM/, 2016.
     :PROPERTIES:
     :RELEVANCE:   mustread
     :END:
The authors argue that, instead of enforcing the same universal fast-path
semantics to all OpenFlow applications and optimizing for the common case,
as it is done in Open vSwitch, a programmable software switch should rather
automatically specialize its dataplane piecemeal with respect to the
configured workload. Tyey introduce ESwitch, a switch architecture that
uses on-the-fly template-based code generation to compile any OpenFlow
pipeline into efficient machine code, which can then be readily used as the
switch fast-path, delivering superior packet processing speed, improved
latency and CPU scalability, and predictable performance.

**** Rétvári et al.: [[https://conferences.sigcomm.org/sigcomm/2017/files/program-netpl/sigcomm17netpl-paper4.pdf][*Dynamic Compilation and Optimization of Packet Processing Programs*]], /ACM SIGCOMM NetPL/, 2017.
     :PROPERTIES:
     :RELEVANCE:   interesting
     :END:
The paper makes the observation that data-plane compilation is
fundamentally statically, i.e., the input of the compiler is a fixed
description of the forwarding plane semantics and the output is code that
can accommodate any packet processing behavior set by the controller at
runtime. The authors advocate a dynamic approach to data plane compilation
instead, where not just the semantics but the intended behavior is also
also input to the compiler, opening the door to a handful of runtime
optimization opportunities that can be leveraged to improve the performance
of custom-compiled datapaths beyond what is possible in a static setting.

*** Packet I/O Libraries

**** Rizzo et al.: [[https://www.usenix.org/system/files/conference/atc12/atc12-final186.pdf][*Netmap: a novel framework for fast packet I/O*]], /USENIX ATC/, 2012.
     :PROPERTIES:
     :RELEVANCE:   important
     :END:
Netmap is a framework that enables commodity operating systems to
handle the millions of packets per seconds, without requiring custom
hardware or changes to applications.  The idea is to eliminate
inefficiencies in OSes' standard packet processing datapaths: per-packet
dynamic memory allocations are removed by preallocating resources, system
call overheads are amortized over large I/O batches, and memory copies are
eliminated by sharing buffers and metadata between kernel and userspace,
while still protecting access to device registers and other kernel memory
areas.

**** Intel et al.: [[http://dpdk.org][*Intel DPDK: Data Plane Development Kit*]], /project website/, 2016.
     :PROPERTIES:
     :RELEVANCE:   important
     :END:
DPDK is a set of libraries and drivers for fast packet processing,
including a multicore framework, huge page memory, ring buffers, poll-mode
drivers for networking I/O, crypto and eventdev, etc.  DPDK can be used to
receive and send packets within the minimum number of CPU cycles (usually
less than 80 cycles), develop fast packet capture algorithms (like
=tcpdump=), and run third-party fast path stacks.

**** fd.io: [[https://fd.io][*The Fast Data Project*]], /project website/, 2016.
     :PROPERTIES:
     :RELEVANCE:   interesting
     :END:
FD.io (Fast data – Input/Output) is a collection of several projects and
libraries to support flexible, programmable and composable services on a
generic hardware platform, using a high-throughput, low-latency and
resource-efficient IO services suitable to many architectures (x86, ARM,
and PowerPC) and deployment environments (bare metal, VM, container).

** Hardware Switch Architectures

**** De Carli et al.: [[http://doi.acm.org/10.1145/1592568.1592593][*PLUG: Flexible Lookup Modules for Rapid Deployment of New Protocols in High-speed Routers*]], /ACM SIGCOMM/, 2009.
     :PROPERTIES:
     :RELEVANCE:   mustread
     :END:
The first incarnation of the "programmable switch". PLUG (Pipelined Lookup
Grid) is a flexible lookup module that can achieve generality without
loosing efficiency, because various custom lookup modules have the same
fundamental features that PLUG retains: area dominated by memories, simple
processing, and strict access patterns defined by the data structure. The
authors IPv4, Ethernet, Ethane, and SEATTLE in a dataflow-based programming
model for the PLUG and mapped them to the PLUG hardware, showing that
throughput, area, power, and latency of PLUGs are close to those of
specialized lookup modules.

**** Anwer et al.: [[http://doi.acm.org/10.1145/1851182.1851206][*SwitchBlade: A Platform for Rapid Deployment of Network Protocols on Programmable Hardware*]], /ACM SIGCOMM/, 2010.
     :PROPERTIES:
     :RELEVANCE:   important
     :END:
SwitchBlade is a platform for rapidly deploying custom protocols on
programmable hardware. SwitchBlade uses a pipeline-based design that allows
individual hardware modules to be enabled or disabled on the fly,
integrates common packet-processing functions as hardware modules enabling
different protocols to use these functions without having to resynthesize
hardware, and uses a customizable forwarding engine that supports both
longest-prefix matching in the packet header and exact matching on a hash
value. SwitchBlade also allows multiple custom data planes to operate in
parallel on the same physical hardware, while providing complete isolation
for protocols running in parallel.

**** Bosshart et al.: [[http://doi.acm.org/10.1145/2486001.2486011][*Forwarding Metamorphosis: Fast Programmable Match-action Processing in Hardware for SDN*]], /ACM SIGCOMM/, 2013.
     :PROPERTIES:
     :RELEVANCE:   mustread
     :END:
This seminal paper presents RMT to overcome two limitations in current
switching chips and OpenFlow: (1) conventional hardware switches are rigid,
allowing "Match-Action" processing on only a fixed set of fields, and (2)
the OpenFlow specification only defines a limited repertoire of packet
processing actions. The RMT (Reconfigurable Match Tables) model is a
RISC-inspired pipelined architecture for switching chips, including an
essential minimal set of action primitives to specify how headers are
processed in hardware. RMT allows the forwarding plane to be changed in the
field without modifying hardware.

**** Brebner et al.: [[https://doi.org/10.1109/MM.2014.19][*High-Speed Packet Processing using Reconfigurable Computing*]], /IEEE Micro/, 2014.
     :PROPERTIES:
     :RELEVANCE:   interesting
     :END:
The paper presents a tool chain that maps a domain-specific declarative
packet-processing language with object-oriented semantics, called PX, to
high-performance reconfigurable-computing architectures based on
field-programmable gate array (FPGA) technology, including components for
packet parsing, editing, and table lookups.

**** Li et al.: [[http://doi.acm.org/10.1145/2934872.2934897][*ClickNP: Highly Flexible and High Performance Network Processing with Reconfigurable Hardware*]], /ACM SIGCOMM/, 2016.
     :PROPERTIES:
     :RELEVANCE:   interesting
     :END:
This paper focuses on accelerating NFs with FPGAs. However, FPGA is
predominately programmed using low-level hardware description languages
(HDLs), which are hard to code and difficult to debug. More importantly,
HDLs are almost inaccessible for most software programmers. This paper
presents ClickNP, a FPGA-accelerated platform, which is highly flexible as
it is completely programmable using high-level C-like languages and exposes
a modular programming abstraction that resembles Click Modular Router, and
also high performance.

**** Chole et al.: [[http://doi.acm.org/10.1145/3098822.3098823][*dRMT: Disaggregated Programmable Switching*]], /ACM SIGCOMM/, 2017.
     :PROPERTIES:
     :RELEVANCE:   important
     :END:
A follow-up to the RMT paper. dRMT (disaggregated Reconfigurable
Match-Action Table) is a new architecture for programmable switches, which
overcomes two important restrictions of RMT: (1) table memory is local to
an RMT pipeline stage, implying that memory not used by one stage cannot be
reclaimed by another, and (2) RMT is hardwired to always sequentially
execute matches followed by actions as packets traverse pipeline
stages. dRMT resolves both issues by disaggregating the memory and compute
resources of a programmable switch, moving table memories out of pipeline
stages and into a centralized pool that is accessible through a
crossbar. In addition, dRMT replaces RMT's pipeline stages with a cluster
of processors that can execute match and action operations in any order.

**** Narayana et al.: [[http://doi.acm.org/10.1145/3098822.3098829][*Language-Directed Hardware Design for Network Performance Monitoring*]], /ACM SIGCOMM/, 2017.
     :PROPERTIES:
     :RELEVANCE:   interesting
     :END:
The authors ask what switch hardware primitives are required to support an
expressive language of network performance questions. They present a
performance query language, Marple, modeled on familiar functional
constructs, backed by a new programmable key-value store primitive on
switch hardware that performs flexible aggregations at line rate and scales
to millions of keys. Marple can express switch queries that could
previously run only on end hosts, while Marple queries only occupy a modest
fraction of a switch's hardware resources.

** Hybrid Hardware/Software Architectures

**** Han et al.: [[http://doi.acm.org/10.1145/1851182.1851207][*PacketShader: A GPU-accelerated Software Router*]], /ACM SIGCOMM/, 2010.
     :PROPERTIES:
     :RELEVANCE:   important
     :END:
PacketShader is a high-performance software router framework for general
packet processing with Graphics Processing Unit (GPU) acceleration,
exploiting the massively-parallel processing power of GPU to address the
CPU bottleneck in software routers, combined with a high-performance packet
I/O engine. The paper presents implementations for IPv4 and IPv6
forwarding, OpenFlow switching, and IPsec tunneling to demonstrate the
flexibility and performance advantage of PacketShader. 

**** Pongrácz et al.: [[http://doi.acm.org/10.1145/2491185.2491204][*Cheap Silicon: A Myth or Reality Picking the Right Data Plane Hardware for Software Defined Networking*]], /ACM HotSDN/, 2013.
     :PROPERTIES:
     :RELEVANCE:   interesting
     :END:
Industry insight holds that programmable network processors are of lower
performance than their hard-coded counterparts, such as Ethernet chips. The
paper argues that, contrast to the common view, the overhead of
programmability is relatively low, and that the apparent difference between
programmable and hard-coded chips is not primarily due to programmability
itself, but because the internal balance of programmable network processors
is tuned to more complex use cases.

**** Kalia et al.: [[https://www.usenix.org/system/files/conference/nsdi15/nsdi15-paper-kalia.pdf][*Raising the Bar for Using GPUs in Software Packet Processing*]], /USENIX NSDI/, 2015.
     :PROPERTIES:
     :RELEVANCE:   interesting
     :END:
The paper opens the debate as to whether Graphics Processing Units (GPUs)
are indeed useful as accelerators for software-based routing and packet
handling applications. The authors argue that for many such applications
the benefits arise less from the GPU hardware itself as from the expression
of the problem in a language such as CUDA or OpenCL that facilitates memory
latency hiding and vectorization through massive concurrency. They then
demonstrate that applying a similar style of optimization to algorithm
implementations, a CPU-only implementation is more resource efficient than
the version running on the GPU.

**** Kaufmann et al.: [[http://doi.acm.org/10.1145/2954679.2872367][*High Performance Packet Processing with FlexNIC*]], /ACM SIGPLAN Not./, 2016.
     :PROPERTIES:
     :RELEVANCE:   interesting
     :END:
The authors argue that the primary reason for high memory and processing
overheads inherent to packer processing applications is the inefficient use
of the memory and I/O resources by commodity network interface cards
(NICs). They propose FlexNIC, a flexible network DMA interface that can be
used to reduce packet processing overheads; FlexNIC allows services to
install packet processing rules into the NIC, which then executes simple
operations on packets while exchanging them with host memory. This moves
some of the packet processing traditionally done in software to the NIC,
where it can be done flexibly and at high speed.

**** Younghwan Go et al.: [[https://www.usenix.org/conference/nsdi17/technical-sessions/presentation/go][*APUNet: Revitalizing GPU as Packet Processing Accelerator*]], /USENIX NSDI/, 2017.
     :PROPERTIES:
     :RELEVANCE:   interesting
     :END:
This is the answer to the question raised by the previous paper.  Kalia et
al. argue that the key enabler for high packet-processing performance is
the inherent feature of GPU that automatically hides memory access latency
rather than its parallel computation power and claim that CPU can
outperform or achieve a similar performance as GPU if its code is
re-arranged to run concurrently with memory access. This paper revists
these claims and find, with eight popular algorithms widely used in network
applications, that (a) there are many compute-bound algorithms that do
benefit from the parallel computation capacity of GPU while CPU-based
optimizations fail to help, and (b) the relative performance advantage of
CPU over GPU in most applications is due to data transfer bottleneck in
PCIe communication of discrete GPU rather than lack of capacity of GPU
itself.

**** Katta et al.: [[http://doi.acm.org/10.1145/2890955.2890969][*CacheFlow: Dependency-Aware Rule-Caching for Software-Defined Networks*]], /ACM SOSR/, 2016.
     :PROPERTIES:
     :RELEVANCE:   interesting
     :END:
The paper presents an architecture to allow high-speed forwarding even with
large rule tables and fast updates, by combining the best of hardware and
software processing. The CacheFlow system caches the most popular rules in
the small TCAM and relies on software to handle the small amount of
cache-miss traffic. The authors observe that one cannot blindly apply
existing cache-replacement algorithms, because of dependencies between
rules with overlapping patterns. Rather long dependency chains must be
broken to cache smaller groups of rules while preserving the semantics of
the policy.

* Miscellaneous Topics

** History

**** Feamster et al.: [[http://doi.acm.org/10.1145/2559899.2560327][*The Road to SDN*]], /ACM Queue/, 2013.
     :PROPERTIES:
     :RELEVANCE:   mustread
     :END:
An intellectual history of programmable networks. A mustread.

**** Zilberman et al.: [[https://doi.org/10.1109/JPROC.2015.2435732][*Reconfigurable Network Systems and Software-Defined Networking*]], /Proceedings of the IEEE/, 2015.
     :PROPERTIES:
     :RELEVANCE:   interesting
     :END:
The paper reviews the state of the art in reconfigurable network systems,
covering hardware reconfiguration, SDN, and the interplay between them. It
starts with a tutorial on software-defined networks, then continues to
discuss programming languages as the linking element between different
levels of software and hardware in the network, reviews electronic
switching systems, highlighting programmability and reconfiguration
aspects, and describes the trends in reconfigurable network
elements.

**** Nick McKeown et al.: [[https://conferences.sigcomm.org/sigcomm/2017/files/program-netpl/01-mckeown.pptx][*Programmable Forwarding Planes are Here to Stay*]], /ACM SIGCOMM NetPL/, 2017.
     :PROPERTIES:
     :RELEVANCE:   mustread
     :END:
A keynote from Nick McKeown at NetPL'17 on the many great research ideas
and new languages that have emerged for programmable forwarding. The talk
considers how we got here, why programmable forwarding planes are
inevitable, why now is the right time, why they are a final frontier for
SDN, and why they are here to stay.

** Large-scale Deployments

**** Casado et al.: [[http://doi.acm.org/10.1145/1282380.1282382][*Ethane: Taking Control of the Enterprise*]], /ACM SIGCOMM/, 2007.
     :PROPERTIES:
     :RELEVANCE:   mustread
     :END:
A seminal paper for deploying SDN in enterprise networks, this paper
presents Ethane, a network architecture allowing managers to define a
single network-wide fine-grain policy and then enforcing it
directly. Ethane couples extremely simple flow-based Ethernet switches with
a centralized controller that manages the admittance and routing of
flows. While radical, this design is backwards-compatible with existing
hosts and switches.  Ethane was implemented in both hardware and software,
supporting both wired and wireless hosts.

**** Jain et al.: [[http://doi.acm.org/10.1145/2486001.2486019][*B4: Experience with a Globally-deployed Software Defined Wan*]], /ACM SIGCOMM/, 2013.
     :PROPERTIES:
     :RELEVANCE:   important
     :END:
The paper presents the design, implementation, and evaluation of B4, a
private WAN connecting Google's data centers across the planet. B4 has a
number of unique characteristics: (1) massive bandwidth requirements
deployed to a modest number of sites, (2) elastic traffic demand that seeks
to maximize average bandwidth, and (3) full control over the edge servers
and network, which enables rate limiting and demand measurement at the
edge. These characteristics led to a Software Defined Networking architecture
using OpenFlow to control relatively simple switches built from merchant
silicon.

**** Qazi et al.: [[http://doi.acm.org/10.1145/3098822.3098848][*A High Performance Packet Core for Next Generation Cellular Networks*]], /ACM SIGCOMM/, 2017.
     :PROPERTIES:
     :RELEVANCE:   important
     :END:
To support deploying SDNs into the Evolved Packet Core (EPC), the paper
presents the design and evaluation of a system architecture for a software
EPC that achieves high and scalable performance. The authors postulate that
the poor scaling of existing EPC systems stems from the manner in which the
system is decomposed, which leads to device state being duplicated across
multiple components, which in turn results in frequent interactions between
the different components. An alternate approach is proposed in which state
for a single device is consolidated in one location and EPC functions are
reorganized for efficient access to this consolidated state. A prototype
for PEPC is also presented, as a software EPC that implements the key
components of the design.

** In-Network Computation

**** Sapio et al.: *[[http://doi.acm.org/10.1145/3152434.3152461][In-Network Computation is a Dumb Idea Whose Time Has Come]]*, /ACM HotNets/, 2017.
     :PROPERTIES:
     :RELEVANCE: important
     :END:
The authors ask the question, given that programmable data plane hardware
creates new opportunities for infusing intelligence into the network, what
kinds of computation should be delegated to the data plane? The paper
discusses the opportunities and challenges for co-designing data center
distributed systems with their network layer, under the constraints imposed
by the limitations of the network machine architecture of programmable
devices. They find that, in particular, aggregation functions raise
opportunities to exploit the limited computation power of networking
hardware to lessen network congestion and improve the overall application
performance.


* COMMENT Local variables
# Local variables:
# eval: (setq reftex-cite-format "%A et al.: [[%U][*%t*]], /%h/, %y.\n")
# End:

